{
    "sourceFile": "crossword.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1710552763840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1710576892958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n             (self.length == other.length)\n         )\n \n     def __str__(self):\n-        return f\"({self.i}, {self.j}) {self.direction} : {self.length}\"\n+        return f\"({self.i}, {self.j}) {self.direction}: {self.length}\"\n \n     def __repr__(self):\n         direction = repr(self.direction)\n         return f\"Variable({self.i}, {self.j}, {direction}, {self.length})\"\n"
                }
            ],
            "date": 1710552763839,
            "name": "Commit-0",
            "content": "class Variable():\n\n    ACROSS = \"across\"\n    DOWN = \"down\"\n\n    def __init__(self, i, j, direction, length):\n        \"\"\"Create a new variable with starting point, direction, and length.\"\"\"\n        self.i = i\n        self.j = j\n        self.direction = direction\n        self.length = length\n        self.cells = []\n        for k in range(self.length):\n            self.cells.append(\n                (self.i + (k if self.direction == Variable.DOWN else 0),\n                 self.j + (k if self.direction == Variable.ACROSS else 0))\n            )\n\n    def __hash__(self):\n        return hash((self.i, self.j, self.direction, self.length))\n\n    def __eq__(self, other):\n        return (\n            (self.i == other.i) and\n            (self.j == other.j) and\n            (self.direction == other.direction) and\n            (self.length == other.length)\n        )\n\n    def __str__(self):\n        return f\"({self.i}, {self.j}) {self.direction} : {self.length}\"\n\n    def __repr__(self):\n        direction = repr(self.direction)\n        return f\"Variable({self.i}, {self.j}, {direction}, {self.length})\"\n\n\nclass Crossword():\n\n    def __init__(self, structure_file, words_file):\n\n        # Determine structure of crossword\n        with open(structure_file) as f:\n            contents = f.read().splitlines()\n            self.height = len(contents)\n            self.width = max(len(line) for line in contents)\n\n            self.structure = []\n            for i in range(self.height):\n                row = []\n                for j in range(self.width):\n                    if j >= len(contents[i]):\n                        row.append(False)\n                    elif contents[i][j] == \"_\":\n                        row.append(True)\n                    else:\n                        row.append(False)\n                self.structure.append(row)\n\n        # Save vocabulary list\n        with open(words_file) as f:\n            self.words = set(f.read().upper().splitlines())\n\n        # Determine variable set\n        self.variables = set()\n        for i in range(self.height):\n            for j in range(self.width):\n\n                # Vertical words\n                starts_word = (\n                    self.structure[i][j]\n                    and (i == 0 or not self.structure[i - 1][j])\n                )\n                if starts_word:\n                    length = 1\n                    for k in range(i + 1, self.height):\n                        if self.structure[k][j]:\n                            length += 1\n                        else:\n                            break\n                    if length > 1:\n                        self.variables.add(Variable(\n                            i=i, j=j,\n                            direction=Variable.DOWN,\n                            length=length\n                        ))\n\n                # Horizontal words\n                starts_word = (\n                    self.structure[i][j]\n                    and (j == 0 or not self.structure[i][j - 1])\n                )\n                if starts_word:\n                    length = 1\n                    for k in range(j + 1, self.width):\n                        if self.structure[i][k]:\n                            length += 1\n                        else:\n                            break\n                    if length > 1:\n                        self.variables.add(Variable(\n                            i=i, j=j,\n                            direction=Variable.ACROSS,\n                            length=length\n                        ))\n\n        # Compute overlaps for each word\n        # For any pair of variables v1, v2, their overlap is either:\n        #    None, if the two variables do not overlap; or\n        #    (i, j), where v1's ith character overlaps v2's jth character\n        self.overlaps = dict()\n        for v1 in self.variables:\n            for v2 in self.variables:\n                if v1 == v2:\n                    continue\n                cells1 = v1.cells\n                cells2 = v2.cells\n                intersection = set(cells1).intersection(cells2)\n                if not intersection:\n                    self.overlaps[v1, v2] = None\n                else:\n                    intersection = intersection.pop()\n                    self.overlaps[v1, v2] = (\n                        cells1.index(intersection),\n                        cells2.index(intersection)\n                    )\n\n    def neighbors(self, var):\n        \"\"\"Given a variable, return set of overlapping variables.\"\"\"\n        return set(\n            v for v in self.variables\n            if v != var and self.overlaps[v, var]\n        )\n"
        }
    ]
}